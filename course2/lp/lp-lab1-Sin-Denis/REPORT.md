# Отчет по лабораторной работе №1
## Работа со списками и реляционным представлением данных
## по курсу "Логическое программирование"

### студент: Син Д.Д.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|   12.11      |       4       |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Список в прологе похож на связный список в обычных императивных языках программирования. Интересным его отличием является то, что в прологе мы выделяем в списке хвост и голову. И также в отличии от тех же C/C++ или Java в списках пролога могут хранится элементы любых типов, что дает дополнительные приятные возможности. Все операции над списками производятся рекурсивно. 

## Задание 1.1: Предикат обработки списка
 
Список в прологе похож на связный список в обычных императивных языках программирования. Интересным его отличием является то, что в прологе мы выделяем в списке хвост и голову. И также в отличии от тех же C/C++ или Java в списках пролога могут хранится элементы любых типов, что дает дополнительные приятные возможности. Все операции над списками производятся рекурсивно. 

## Задание 1.1: Предикат обработки списка
 
`delete(X, N, Y)` - Предикат удаляет первые N элементов из списка X и результатом удаления первых N элементов из X будет являться список Y.
`delete2(X, N, Y)` - Делает тоже самое, что и предиакт delete, но реализован он с помощью стандартных предикатов для работы со списками.

Примеры использования:
```prolog
?- delete([a, b, c, d, e], 2, [c, d, e]).
true .
?- delete([a, b, c, d, e], 2, X).
X = [c, d, e] .
?- delete([a, b, c, d, e], 0, X).
X = [a, b, c, d, e] .
?- delete([a, b, c, d, e], 4, X).
X = [e] .
?- delete([a, b, c, d, e], 5, X).
X = [].
?- delete([a, b, c, d, e, f], N, [c, d, e, f]).
N = 2 .
```

Реализация:
Без использования стандартных предикатов
```
delete(X, 0, X).
delete([X|Y], N, Z) :-
	delete(Y, Q, Z),
	N is Q + 1.
```
С использованием стандратных предикатов
```
delete2(X, N, Y) :-
	my_append(A, Y, X),
	my_length(A, N).
```

При реализации предиката `delete(X, N, Y)` мы определяем предикат при удалении 0 элемнетов, в этом случае очевидно, что список Y будет списком X. Далее рекурсивно определяем предикат уже для N элементов. Мы говорим что удалить из списка [X|Y] N элементов значит то же что удалить из списка Y Q элементов и причем N должно быть равно Q + 1.

При реализации предиката `delete2(X, N, Y)` были использованы стандартные предикаты для работы со списками my_append и mylenght, которые были заранее реализованы. Мы говорим, что удаляем из списка X N элементов и получаем в результате список Y, если мы можем найти такое разбиение списка X на 2 части, где первой частью будет список A, а второй частью будет список Y, и причем длина списка A должна быть N.

## Задание 1.2: Предикат обработки числового списка

`arithm_mean(X, T)` - предикат, вычисляющий среднее арифметическое значение элементов списка, он использует дополнииельный предикат `sum(X, S)`, который вычисляет сумму элементов списка.

Примеры использования:
```
?- arithm_mean([1, 2, 3, 4], N).
N = 2.5.
?- arithm_mean([1, 2, 3, 4, 5], N).
N = 3.
?- arithm_mean([1, 2], N).
N = 1.5.
```

Реализация:
```
sum([], 0).
sum([X|Y], S) :-
	sum(Y, Q),
	S is Q + X.

arithm_mean(X, T) :-
	length(X, L),
	sum(X, P),
	T is P / L.
```

Предикат`arithm_mean(X, T)` истинен, если длина списка X равна L и сумма списка X равна P и T равно P / L. Предикат `sum(X, N)` определяется рекурсивно. Сумма пустого списка равна 0. Далее `sum([X|Y], S)` истина, если сумма списка Y равна Q и при этом S равно сумме Q и элемента X.

## Задание 2: Реляционное представление данных

Преимуществом релеационного представления данных является то, что все данные задаются в виде отношений, поэтому можно в строгой математической форме описать обработку дынных. Самым большим на мой взгляд минусом является скорость доступа к данным.

`mark(Student, N)` - Предикат для получения оценки Студента по прдеметам. Здесь просто проходимся по всем предметам и из предмета получаем оценку студента.
`student_point_average(Student, Res)` - Предикат для получения среднего балла ученика по всем предметам внутри запускается предикат findall от предиката mark, таким образом получаем список всех оценок и от этого списка получаем среднее арифметическое.
`students_point_average_in_group(Group, Res)` - Предикат для получения среднего бала ученика в какой либо группе. Здесь из группы получаем список студентов и с помощью предиката member получаем студента из данной группы и вызываем для него предикат `student_point_average`.
`group_point_average_print()` - Предикат, который печатает средний бал для каждой группы. В данном случае с помощью `findall` и `students_point_average_in_group` получаем список средних балов всех студентов данной группы и вычисляем от этого списка среднее арифметическое значние и печатаем номер группы и полученное значение.
`repass(Subj, Name)` - Предикат для получения студента не сдавшего предмет Subj. Получаем список студентов по предмету и с помощью предиката member получаем имя студента у которого grde(Name, 2).
`print_repass()` - Предикат, который печатает предметы и списки не сдавших данные предметы. С помощью findall и repass получаем список всех кто не сдал предмет и печатаем предмет и список несдавших.
`group_repass(Group, Name)` - Предикат для получения не сдавших студентов в какой либо группе. Находим студента, который принадлежит списку студентов данной группы и у которго grade(Name, 2), по какому либо из предметов.
`num_repass_in_group(Group, Num)` - Предикат, который подсчитывает количество не сдавших студентов в группе. С помощью findall и group_repass получаем список всех несдавших студентов их данной группы и с помощью предиката length находим длину списка не сдавших студетов.
`print_num_repass()` - Предикат, который печатает номер группы и количество несдавших студентов. С помощью num_repass_in_group получаем количество несдавших для каждой группы и печатаем номер группы и это количество.

Реализация:
```
% Задание 1 Получить таблицу групп и средний балл по каждой из групп
sum([], 0).
sum([X|Y], S) :-
	sum(Y, Q),
	S is Q + X.

arithm_mean(X, T) :-
	length(X, L),
	sum(X, P),
	T is P / L.

mark(Student, N) :-
	subject(_, X),
	member(grade(Student, N), X).

student_point_average(Student, Res) :-
	findall(N, mark(Student, N), List),
	arithm_mean(List, Res).

students_point_average_in_group(Group, Res) :-
	group(Group, StudList),
	member(Stud, StudList),
	student_point_average(Stud, Res).

group_point_average_print() :-
	group(Group, _),
	findall(Res, students_point_average_in_group(Group, Res), ListValue),
	arithm_mean(ListValue, Ans),
	write('Группа: '), write(Group), write(' Средний бал: '), write(Ans), write('\n'), fail.

% Задание 2 Для каждого предмета получить список студентов, не сдавших экзамен (grade=2)
repass(Subj, Name) :-
	subject(Subj, Students),
	member(grade(Name, 2), Students).

print_repass() :-
	subject(Subj, _),
	findall(Name, repass(Subj, Name), List),
	write('Предмет: '), write(Subj), write(' Не сдали: '), write(List), write('\n'), fail.

% Задание 3 Найти количество не сдавших студентов в каждой из групп
group_repass(Group, Name) :-
	subject(_, X),
	group(Group, Y),
	member(Name, Y),
	member(grade(Name, 2), X).

num_repass_in_group(Group, Num) :-
	findall(Name, group_repass(Group, Name), List),
	length(List, Num).
	
print_num_repass() :-
	group(Group, _),
	num_repass_in_group(Group, Num),
	write('Группа: '), write(Group), write(' Несдавших: '), write(Num), write('\n'), fail.
```

Пример работы:
```
?- group_point_average_print.
Группа: 102 Средний бал: 3.9444444444444446
Группа: 101 Средний бал: 3.9666666666666672
Группа: 104 Средний бал: 3.861111111111111
Группа: 103 Средний бал: 4.145833333333334
false.

?- print_repass.
Предмет: Логическое программирование Не сдали: [Петровский,Сидоров,Джаво]
Предмет: Математический анализ Не сдали: [Петров]
Предмет: Функциональное программирование Не сдали: []
Предмет: Информатика Не сдали: [Сиплюсплюсов,Криптовалютников]
Предмет: Английский язык Не сдали: [Решетников,Азурин]
Предмет: Психология Не сдали: [Безумников,Круглосчиталкин]
false.

?- print_num_repass.
Группа: 102 Несдавших: 3
Группа: 101 Несдавших: 3
Группа: 104 Несдавших: 2
Группа: 103 Несдавших: 2
false.
```

## Выводы
В данной лабораторной работе я в первый раз программировал на языке логического программирования prolog. И самое интересное, что здесь нужно совсем иначе мыслить при написании программы в отличии например от программировании на императивных языках. Сложность заключается в том, что предикаты это не функции и они не возвращают значений и могут вызываться в нескольких режимах. Интересны также такие возможности, как бектрекинг и унификация. Все эти возможности позволяют писать меньше кода чем на том же Си, но и код получается не в виде набора команд, а в виде определений. Другими словами мы не говорим машине делай одно действие, затем другое и так далее, а мы просто говорим например сумма в нашем понимании определется вот так. Из минусов я хотел бы выделить 2 вещи. Первая, это то, что для каких либо вычислений prolog использует полный перебор, что сказывается на эффективности программы. Вторая, это то, что нет типизации и можно совершать много ошибок при написании программ. Также в prolog интересная реализация списков. Элементами списка тут могут быть любые структуры. И как показала втораая часть лабораторной работы из реляционного представления данных на prolog можно легко и быстро доставать любую информацию. В итоге на prolog очень коротко можно написать многие вещи, которые занимали бы на других языках больше кода, но чтобы написать эти вещи нужно думать не в процедурном стиле, а в декларативном.
